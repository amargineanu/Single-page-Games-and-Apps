<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple Tetris - Single File</title>
  <style>
    /* Basic layout */
    :root{--cell:30px;--cols:10;--rows:20}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;display:flex;gap:20px;align-items:flex-start;justify-content:center;height:100vh;background:#0b1220;color:#e6eef8}
    .wrap{display:flex;gap:20px;align-items:flex-start}
    canvas{background:#071022;image-rendering:pixelated;border-radius:6px;box-shadow:0 8px 30px rgba(2,6,23,.7)}
    .panel{width:220px}
    h1{font-size:16px;margin:0 0 8px}
    .score{font-size:14px;margin:6px 0}
    .controls{font-size:13px;line-height:1.6;opacity:.95}
    button{background:#15304a;border:0;color:#dff; padding:8px 10px;border-radius:6px;cursor:pointer}
    button:hover{filter:brightness(1.1)}
    .small{font-size:12px;color:#bcd}
    footer{position:fixed;bottom:8px;left:8px;font-size:12px;color:#7f99b2}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="300" height="600"></canvas>
    <div class="panel">
      <h1>Simple Tetris</h1>
      <div class="score">Score: <span id="score">0</span></div>
      <div class="score">Level: <span id="level">1</span></div>
      <div class="score">Lines: <span id="lines">0</span></div>
      <div style="margin:12px 0;"><button id="start">Start / Restart</button> <button id="pause">Pause</button></div>
      <div class="controls">
        <div><strong>Controls</strong></div>
        <div class="small">← / → : move</div>
        <div class="small">↓ : soft drop</div>
        <div class="small">Space : hard drop</div>
        <div class="small">↑ / X : rotate</div>
        <div class="small">Z : rotate other way</div>
        <div class="small">P : pause</div>
      </div>
      <div style="margin-top:14px;" class="small">This is a compact, single-file implementation of Tetris. Works on desktop browsers.</div>
    </div>
  </div>
  <footer>Built for you — open the file and play!</footer>

  <script>
  // ---- Configuration ----
  const COLS = 10, ROWS = 20;
  const CELL = 30; // px
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * CELL;
  canvas.height = ROWS * CELL;

  // Colors for tetrominoes
  const COLORS = {
    I: '#49c6ff',
    J: '#2f74ff',
    L: '#ff9f3a',
    O: '#ffd24a',
    S: '#4efc6a',
    T: '#d86cff',
    Z: '#ff5c7a'
  };

  // Tetromino shapes in rotation states
  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ],
    J: [
      [[1,0,0],[1,1,1],[0,0,0]],
      [[0,1,1],[0,1,0],[0,1,0]],
      [[0,0,0],[1,1,1],[0,0,1]],
      [[0,1,0],[0,1,0],[1,1,0]]
    ],
    L: [
      [[0,0,1],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,0],[0,1,1]],
      [[0,0,0],[1,1,1],[1,0,0]],
      [[1,1,0],[0,1,0],[0,1,0]]
    ],
    O: [
      [[1,1],[1,1]]
    ],
    S: [
      [[0,1,1],[1,1,0],[0,0,0]],
      [[0,1,0],[0,1,1],[0,0,1]]
    ],
    T: [
      [[0,1,0],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,1],[0,1,0]],
      [[0,0,0],[1,1,1],[0,1,0]],
      [[0,1,0],[1,1,0],[0,1,0]]
    ],
    Z: [
      [[1,1,0],[0,1,1],[0,0,0]],
      [[0,0,1],[0,1,1],[0,1,0]]
    ]
  };

  // ---- Game State ----
  let grid, current, nextPiece, score, level, linesCleared, dropCounter, dropInterval, lastTime, gameOver, paused;

  function initGame(){
    grid = createMatrix(ROWS, COLS);
    score = 0; level = 1; linesCleared = 0;
    dropInterval = 800; // ms at level 1
    current = createPiece(randomPiece());
    nextPiece = createPiece(randomPiece());
    dropCounter = 0; lastTime = 0; gameOver = false; paused = false;
    updateUI();
  }

  function createMatrix(r, c){
    const m = [];
    for(let i=0;i<r;i++) m.push(new Array(c).fill(0));
    return m;
  }

  function randomPiece(){
    const keys = Object.keys(SHAPES);
    return keys[Math.floor(Math.random() * keys.length)];
  }

  function createPiece(type){
    const states = SHAPES[type];
    const state = 0;
    return {
      type,
      states,
      state,
      matrix: states[state],
      row: 0,
      col: Math.floor((COLS - states[state][0].length) / 2)
    };
  }

  // Rotate matrix clockwise
  function rotate(piece, dir=1){
    const states = piece.states;
    piece.state = (piece.state + dir + states.length) % states.length;
    piece.matrix = states[piece.state];
    // wall kick: try small adjustments if collision
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collide(grid, piece, piece.row, piece.col + k)){
        piece.col += k; return true;
      }
    }
    // can't rotate
    piece.state = (piece.state - dir + states.length) % states.length;
    piece.matrix = states[piece.state];
    return false;
  }

  function collide(mat, piece, testRow, testCol){
    const m = piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        if(m[r][c]){
          const y = testRow + r;
          const x = testCol + c;
          if(x < 0 || x >= COLS || y >= ROWS) return true;
          if(y >=0 && mat[y][x]) return true;
        }
      }
    }
    return false;
  }

  function merge(mat, piece){
    const m = piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        if(m[r][c]){
          const y = piece.row + r;
          const x = piece.col + c;
          if(y>=0) mat[y][x] = piece.type;
        }
      }
    }
  }

  function sweep(){
    let rowCount = 0;
    for(let y=ROWS-1;y>=0;y--){
      if(grid[y].every(v => v !== 0)){
        grid.splice(y,1);
        grid.unshift(new Array(COLS).fill(0));
        rowCount++;
        y++; // recheck same row index since we shifted
      }
    }
    if(rowCount>0){
      const points = [0,40,100,300,1200]; // standard scoring
      score += (points[rowCount] || 0) * level;
      linesCleared += rowCount;
      level = Math.floor(linesCleared / 10) + 1;
      // speed up
      dropInterval = Math.max(100, 800 - (level-1)*70);
    }
    return rowCount;
  }

  function playerDrop(){
    if(collide(grid, current, current.row+1, current.col)){
      // lock piece
      merge(grid, current);
      const cleared = sweep();
      if(cleared>0) score += cleared * 10 * level; // extra
      // spawn next
      current = nextPiece;
      current.row = 0;
      current.col = Math.floor((COLS - current.matrix[0].length)/2);
      nextPiece = createPiece(randomPiece());
      if(collide(grid, current, current.row, current.col)){
        gameOver = true;
      }
    } else {
      current.row++;
    }
    dropCounter = 0;
    updateUI();
  }

  function hardDrop(){
    while(!collide(grid, current, current.row+1, current.col)){
      current.row++;
      score += 2; // reward
    }
    playerDrop();
  }

  function updateUI(){
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = linesCleared;
  }

  // ---- Drawing ----
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw grid background
    ctx.fillStyle = '#071022';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw locked pieces
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(grid[r][c]) drawCell(c,r, COLORS[grid[r][c]] || '#999');
      }
    }
    // draw current piece
    const m = current.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        if(m[r][c]){
          const x = current.col + c;
          const y = current.row + r;
          if(y>=0) drawCell(x,y, COLORS[current.type]);
        }
      }
    }

    // grid lines (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let x=0;x<=COLS;x++){
      ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,canvas.height); ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(canvas.width,y*CELL); ctx.stroke();
    }
  }

  function drawCell(x,y,color){
    const px = x * CELL;
    const py = y * CELL;
    // block background
    ctx.fillStyle = color;
    ctx.fillRect(px+1, py+1, CELL-2, CELL-2);
    // bright highlight
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(px+3, py+3, CELL/2, 4);
    // darker bottom shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(px+1, py+CELL-6, CELL-2, 5);
  }

  // ---- Game loop ----
  function update(time=0){
    if(!lastTime) lastTime = time;
    const delta = time - lastTime;
    lastTime = time;
    if(!paused && !gameOver){
      dropCounter += delta;
      if(dropCounter > dropInterval){
        playerDrop();
      }
      draw();
    } else {
      draw();
      if(gameOver){
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
        ctx.fillStyle = '#fff';
        ctx.font = '24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
        ctx.font = '14px system-ui';
        ctx.fillText('Press Start to play again', canvas.width/2, canvas.height/2 + 26);
      }
      if(paused && !gameOver){
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, canvas.height/2 - 30, canvas.width, 60);
        ctx.fillStyle = '#fff';
        ctx.font = '20px system-ui'; ctx.textAlign='center';
        ctx.fillText('Paused', canvas.width/2, canvas.height/2 + 6);
      }
    }
    requestAnimationFrame(update);
  }

  // ---- Input ----
  document.addEventListener('keydown', (e)=>{
    if(gameOver) return;
    if(e.key === 'ArrowLeft'){
      if(!collide(grid, current, current.row, current.col-1)) current.col--;
    } else if(e.key === 'ArrowRight'){
      if(!collide(grid, current, current.row, current.col+1)) current.col++;
    } else if(e.key === 'ArrowDown'){
      if(!collide(grid, current, current.row+1, current.col)) { current.row++; score++; }
    } else if(e.key === ' '){ // space hard drop
      e.preventDefault(); hardDrop();
    } else if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'x'){
      rotate(current, 1);
    } else if(e.key.toLowerCase() === 'z'){
      rotate(current, -1);
    } else if(e.key.toLowerCase() === 'p'){
      togglePause();
    }
    updateUI();
  });

  // Buttons
  document.getElementById('start').addEventListener('click', ()=>{
    initGame();
  });
  document.getElementById('pause').addEventListener('click', ()=>{
    togglePause();
  });

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
  }

  // Start
  initGame();
  requestAnimationFrame(update);

  </script>
</body>
</html>
